---
description: Express backend patterns for the StudySprint server
globs:
  - server/src/**/*.js
alwaysApply: false
---

# Backend Rules - Express & Server Code

## Controller Pattern

Always wrap controller functions with `asyncHandler` for automatic error handling.

```javascript
import { asyncHandler } from '../helpers/asyncHandler.js'
import Blog from '../models/Blog.js'

// Good
export const getAllBlogs = asyncHandler(async (req, res) => {
  const blogs = await Blog.find({ isPublished: true })
  res.json({
    success: true,
    count: blogs.length,
    blogs
  })
})

// Bad - no asyncHandler wrapper
export const getAllBlogs = async (req, res) => {
  try {
    const blogs = await Blog.find({ isPublished: true })
    res.json({ success: true, blogs })
  } catch (error) {
    res.status(500).json({ success: false, message: error.message })
  }
}
```

## Response Format

**Always use consistent response structure:** `{ success, message, data }`

Use response helpers from `helpers/response.js`:

```javascript
import { sendSuccess, sendError, sendData } from '../helpers/response.js'

// Good - consistent responses
export const createBlog = asyncHandler(async (req, res) => {
  const blog = await Blog.create(req.body)
  
  return sendSuccess(res, { blog }, 'Blog created successfully', 201)
})

export const getBlog = asyncHandler(async (req, res) => {
  const blog = await Blog.findById(req.params.id)
  
  if (!blog) {
    return sendError(res, 'Blog not found', 404)
  }
  
  return sendData(res, { blog })
})
```

## Validation

Validate input at the beginning of functions. Use early returns for errors.

```javascript
// Good - validation first, early return
export const addBlog = asyncHandler(async (req, res) => {
  const { title, description, category } = req.body
  const imageFile = req.file

  if (!title || !description || !category || !imageFile) {
    return res.status(400).json({
      success: false,
      message: 'Missing required fields'
    })
  }

  const blog = await Blog.create({ title, description, category, image: imageFile.filename })
  res.status(201).json({ success: true, blog })
})

// Bad - validation after processing
export const addBlog = asyncHandler(async (req, res) => {
  const blog = await Blog.create(req.body)
  
  if (!blog.title) {
    return res.status(400).json({ success: false })
  }
})
```

## Middleware Validators

Use validators as middleware instead of inline validation.

```javascript
// validators/blogValidator.js
export const validateBlogInput = (req, res, next) => {
  const { title, description, category } = req.body.blog ? JSON.parse(req.body.blog) : {}
  const errors = []

  if (!title || title.trim().length < 3) {
    errors.push('Title must be at least 3 characters')
  }
  
  if (errors.length > 0) {
    return res.status(400).json({
      success: false,
      message: 'Validation failed',
      errors
    })
  }

  next()
}
```

## Route Organization

Organize routes: public first, then apply auth middleware, then protected routes.

```javascript
import express from 'express'
import { 
  addBlog, 
  deleteBlogById, 
  getAllBlogs, 
  getBlogById, 
  publishBlog,
  unpublishBlog 
} from '../controllers/blogController.js'
import upload from '../middleware/multer.js'
import auth from '../middleware/auth.js'
import { validateBlogInput } from '../validators/blogValidator.js'

const router = express.Router()

// Public routes (before auth middleware)
router.get('/all', getAllBlogs)
router.get('/:blogId', getBlogById)

// Apply auth middleware - all routes below are protected
router.use(auth)

// Protected routes (after auth middleware)
router.post('/add', upload.single('image'), validateBlogInput, addBlog)
router.post('/delete', deleteBlogById)
router.post('/publish', publishBlog)
router.post('/unpublish', unpublishBlog)

export default router
```

## Apply Rate Limiters

Use rate limiters for sensitive endpoints.

```javascript
import { commentLimiter, generateLimiter } from '../middleware/rateLimiter.js'

// Rate limited routes
router.post('/add-comment', commentLimiter, validateComment, addComment)
router.post('/generate', generateLimiter, generateContent)
```

## HTTP Status Codes

Use appropriate status codes:

- **200** - Success (GET, PUT)
- **201** - Created (POST)
- **400** - Bad Request (validation errors)
- **401** - Unauthorized (no/invalid token)
- **404** - Not Found
- **500** - Internal Server Error

```javascript
// Good - appropriate status codes
export const createBlog = asyncHandler(async (req, res) => {
  const blog = await Blog.create(req.body)
  res.status(201).json({ success: true, blog })  // 201 for creation
})

export const getBlog = asyncHandler(async (req, res) => {
  const blog = await Blog.findById(req.params.id)
  
  if (!blog) {
    return res.status(404).json({ success: false, message: 'Not found' })  // 404
  }
  
  res.json({ success: true, blog })  // 200 (default)
})
```

## Mongoose Models

Use consistent schema patterns with timestamps.

```javascript
import mongoose from 'mongoose'

const blogSchema = new mongoose.Schema({
  title: { type: String, required: true },
  description: { type: String, required: true },
  category: { type: String, required: true },
  author: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  isPublished: { type: Boolean, default: false }
}, { timestamps: true })  // Always include timestamps

const Blog = mongoose.model('Blog', blogSchema)

export default Blog
```

## Authentication Middleware

Access authenticated user data via `req.user` (set by auth middleware).

```javascript
// middleware/auth.js sets req.user
export const createBlog = asyncHandler(async (req, res) => {
  const blog = await Blog.create({
    ...req.body,
    author: req.user.userId,      // From auth middleware
    authorName: req.user.name     // From auth middleware
  })
  
  res.status(201).json({ success: true, blog })
})
```

## File Upload

Use Multer middleware for file uploads. Store files locally.

```javascript
import upload from '../middleware/multer.js'

// Route with file upload
router.post('/add', upload.single('image'), validateBlogInput, addBlog)

// Controller handling upload
export const addBlog = asyncHandler(async (req, res) => {
  const imageFile = req.file  // Multer adds this
  
  if (!imageFile) {
    return res.status(400).json({ success: false, message: 'Image required' })
  }
  
  const imagePath = `/uploads/blogs/${imageFile.filename}`
  const blog = await Blog.create({ ...req.body, image: imagePath })
  
  res.status(201).json({ success: true, blog })
})
```
